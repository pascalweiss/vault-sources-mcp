Below is a **single, long-form Markdown document** intended to be handed to a dev team.
It is **architecture- and requirements-focused**, intentionally **no full code**, but precise enough to implement without ambiguity.

---

# vault-sources-mcp

**An MCP Server for Tracking AI Input → Obsidian Vault Provenance**

---

## 1. Purpose & Problem Statement

### 1.1 Core Problem

An AI agent is used to **populate and edit an Obsidian vault** based on external inputs such as:

* YouTube transcripts
* Book excerpts
* Articles
* Arbitrary pasted text

Over time, the vault becomes a **knowledge base authored by an AI**, but:

* It becomes unclear **which input(s)** caused a given markdown note to exist or change
* Inputs are ephemeral (chat history, copy-paste, URLs) and not persisted
* There is no structured way to:

  * audit AI-generated knowledge
  * clean up broken references
  * recover from inconsistencies
  * answer “where did this come from?”

### 1.2 Goal of vault-sources-mcp

`vault-sources-mcp` is an **MCP (Model Context Protocol) server** whose sole responsibility is to:

> Persist *inputs* and track their *relationships* to markdown notes in an Obsidian vault,
> **without** being responsible for editing the vault itself.

In short:

> **“Given a note, find its sources. Given a source, find affected notes.”**

---

## 2. Design Philosophy

### 2.1 Strong Separation of Concerns

| Component             | Responsibility                                                           |
| --------------------- | ------------------------------------------------------------------------ |
| **Agent**             | Reads/writes markdown files, injects frontmatter, asks user for approval |
| **vault-sources-mcp** | Stores inputs, IDs, relations, events, reconciliation logic              |
| **User**              | Final authority for irreversible or intrusive actions                    |

The MCP server:

* **Never edits markdown files**
* **Never scans the vault**
* **Never assumes filesystem access**

All vault interactions are mediated by the agent.

---

### 2.2 Provenance, Not Content Duplication

* Inputs are stored **outside the vault**
* Inputs are **not markdown**
* Notes do **not link** to inputs
* Relationships exist **only in the database**

This avoids polluting the knowledge graph with operational metadata.

---

### 2.3 Auditability Over Convenience

The system favors:

* immutability
* append-only events
* explicit user approvals
* recoverability

over:

* silent auto-fixes
* hidden heuristics
* implicit assumptions

---

## 3. High-Level Architecture

```
+--------------------+
|      User          |
+---------+----------+
          |
          v
+--------------------+        MCP Calls        +------------------------+
|      AI Agent      | <--------------------> |   vault-sources-mcp     |
| (Claude, Cursor,   |                        |   (TypeScript Server)   |
|  etc.)             |                        +-----------+------------+
|                    |                                    |
| - edits markdown   |                                    |
| - injects IDs      |                                    |
| - asks approvals   |                                    |
+--------------------+                                    |
                                                         v
                                               +------------------+
                                               |   SQLite DB      |
                                               | (inputs, links,  |
                                               |  notes, events)  |
                                               +------------------+
```

---

## 4. Core Concepts

### 4.1 Inputs

An **input** is any raw text provided to the agent that contributes to knowledge creation.

Examples:

* full YouTube transcript
* excerpt of a book chapter
* copied article text

Properties:

* Immutable
* Persisted forever (unless explicitly redacted)
* Stored as raw text (not markdown)

---

### 4.2 Notes

A **note** is a markdown file in the Obsidian vault that:

* Contains a **managed frontmatter ID**
* Is created or edited by the agent
* Is referenced only by its stable ID, not its file path

The MCP server does **not** know file paths, titles, or folders.

---

### 4.3 Provenance Links

A **link** expresses:

> “This input influenced this note.”

* Many-to-many
* Whole-note granularity (no block or range tracking)
* Directional but queryable both ways

---

### 4.4 Events (Critical)

Every meaningful action produces an **event**.

Events are:

* append-only
* immutable
* timestamped
* the foundation for reconciliation and audit

---

## 5. Identifiers

### 5.1 Note IDs

* Generated by the MCP server
* Format: **UUIDv7**
* Injected into markdown frontmatter by the agent
* Key name derived from server name

**Frontmatter key:**

```yaml
vault_sources_mcp_id: <uuidv7>
```

Rules:

* MCP server **refuses to track provenance** for notes without this ID
* Agent must ask the user before injecting it

---

### 5.2 Input IDs

Each input has:

* `input_id` → UUIDv7 (primary key)
* `content_sha256` → integrity + deduplication

---

## 6. Storage & Initialization

### 6.1 Database Choice

* **SQLite**
* File-based
* Lives inside project directory
* Zero external dependencies

Default suggested path:

```
./data/vault-sources.sqlite
```

---

### 6.2 First-Run Behavior

If no database exists:

1. MCP server returns a structured “DB not initialized” response
2. Agent must:

   * ask user whether to create DB
   * ask for location (default = project root)
3. Agent calls explicit `db.init` command

No silent creation is allowed.

---

## 7. Data Model (Conceptual)

### 7.1 Inputs

Fields:

* `input_id`
* `content`
* `content_sha256`
* `state` (`active` | `redacted`)
* `created_at`
* `meta_json`

Rules:

* Content is immutable
* Redaction hides content but preserves metadata + links

---

### 7.2 Notes

Fields:

* `note_id`
* `created_at`
* `last_seen_at`
* `meta_json`

Notes are registered lazily when the agent reports them.

---

### 7.3 Input–Note Links

Fields:

* `input_id`
* `note_id`
* `created_at`

Composite uniqueness enforced.

---

### 7.4 Events (Append-Only)

Examples of event types:

* `DB_INITIALIZED`
* `INPUT_STORED`
* `INPUT_REDACTED`
* `NOTE_SEEN`
* `LINK_ADDED`
* `LINK_REMOVED`
* `NOTE_MARKED_DELETED`
* `NOTES_MERGED`

Events store:

* type
* timestamp
* relevant IDs
* structured payload (JSON)

---

## 8. MCP Tooling Requirements

### 8.1 Database Management

* Check DB status
* Initialize DB
* No implicit side effects

---

### 8.2 ID Management

* Generate UUIDv7 note IDs
* Expose frontmatter key
* No vault access

---

### 8.3 Input Management

* Persist input text
* Hash + normalize content
* Optional deduplication
* Redact input on request

---

### 8.4 Provenance Linking

* Add/remove links
* Query links by note or by input
* Enforce existence of IDs

---

### 8.5 Reconciliation & Recovery

The MCP server must support **diagnosis**, not automatic fixes.

Examples:

* Find notes not seen for N days
* Find links pointing to stale notes
* Find inputs never linked
* Produce **action plans**, not direct edits

The agent:

* inspects the vault
* asks user approval
* executes fixes
* reports back via MCP calls

---

## 9. Trust & Enforcement Model

| Rule                      | Enforcement          |
| ------------------------- | -------------------- |
| Notes must have IDs       | MCP refuses to link  |
| IDs must be user-approved | Agent responsibility |
| Vault consistency         | Agent responsibility |
| DB consistency            | MCP responsibility   |

This is **protocol-level enforcement**, not filesystem enforcement.

---

## 10. Constraints (Explicit)

* ❌ MCP server must not read or write markdown files
* ❌ MCP server must not assume Obsidian APIs
* ❌ No implicit user actions
* ❌ No background vault scanning
* ❌ No markdown storage for inputs

---

## 11. Non-Goals

* Versioning note content
* Block-level provenance
* Visual graph UI
* Obsidian plugin
* Search inside inputs (can be added later)

---

## 12. Extensibility Considerations

Future-safe decisions already made:

* UUIDv7
* event log
* immutable inputs
* vault-agnostic design

Future extensions could include:

* Postgres adapter
* provenance graphs
* confidence scoring
* LLM-generated explanations
* cross-vault support

---

## 13. Summary (Mental Model)

> **vault-sources-mcp is not a note tool.
> It is a provenance ledger.**

It answers:

* *Where did this note come from?*
* *Which inputs influenced this knowledge?*
* *What did the agent do, and when?*
* *What is broken, missing, or orphaned?*

And it does so **without touching the vault**,
while remaining **auditable, explicit, and recoverable**.

---

If you want, next I can:

* derive the **exact MCP tool schema**
* write a **README.md for public release**
* or produce **acceptance criteria / test scenarios** for the dev team

